from sage.rings.integer_ring import ZZ

def compose(Ps, f, g=1):
    """
    Compute the numerator of Ps(f/g). Ps is a list of coefficients.

    This algorithm is a derecursivization of algorithm 1 in the
    paper. Since it is non-trivial, I give some details on how it
    works.

    The recursive algorithm uses a binary divide-and-conquer to
    compute P[f,g]. It splits P in two halves P0 and P1 of
    approximately the same size, and computes

        P[f,g] = g^(deg P1 + 1) P0[f,g] + f^(deg P0 + 1) P1[f,g]

    Let n = deg P + 1. If n is a power of two, then the algorithm
    follows a balanced binary tree and the derecursivization is
    obvious. Hard times come if n is not a power of two and we want to
    simulate exactly the recursive algorithm in order to avoid
    unnecessary computations.

    Stated as in the paper, if n is even, P is splitted in two halves
    of equal size; if n is odd, P1 has one coefficient more than
    P0. I'll use n = 6 as an example. It will be useful to think of f
    and g as linear functions, and of P as a univariate polynomial, so
    that all complexity estimates can be expressed in terms of n;
    everything that follows can be easily generalized to the more
    general setting of the actual algorithm. Here's the tree of calls
    generated by the recursive algorithm

              110           0
             /   \
            11   11         1
           / \   / \
          1  10 1  10       1
             / \   / \
             1 1   1 1

    The nodes in the tree are labeled with the binary expansion of the
    degree of the polynomials P0 and P1 plus one. The binary expansion
    of n is reported on the right (lsb on top). The classical
    derecursivization scans the tree in bottom-first-left-first order;
    at any moment, only one path from the root to an interior node is
    stored in memory, so that the space used never exceeds O(n).

    Here I implement a derecursivization which scans the tree level by
    level bottom-up. In some sense, it allows to do the computation
    "in place", although "in place" doesn't mean much in python's
    memory model; and although, to really be in place, we would need
    "in place" polynomial multiplication, which I don't think
    exists. In the end I suspect that this algorithm, if properly
    implemented in C, could save some mallocs, but probably the
    improvement would be barely noticeable. In python, it is just
    simpler to implement.

    Count levels from top to bottom starting at 0. Observe that the
    leftmost node on level h is labeled with the binary expansion of
    n, shifted to the right by h. It is easy to show by induction
    that, at any level, the maximum difference between any two nodes
    on the same level is at most 1. Hence, at any level, a node is
    either labeled with

        (-)  n >> h

    or

        (+)  (n >> h) + 1

    So, let's simplify the diagram by simply coloring the nodes white
    (-) or black (+):

              -         0
             / \
            -   -       1
           / \ / \
           - + - +      1
            / \ / \
            + + + +

    In front of any level, is the least significant bit of the label
    of the leftmost node. From this bit, and from the color of one
    node, we can deduce the color of its two children, and
    reciprocally:

         -  0    -  1    +  0    +  1
        / \     / \     / \     / \
        - -     - +     - +     + +

    Enter now, the classical bijection between the interval [0,2^h[
    and the leaves of a balanced binary tree of height h. Couting
    leaves from left to right, the i-th leave is reached starting from
    the root, reading the binary expansion of i on l digits msb-first,
    going left on 0 and right on 1. Here's an example with i=3 and h=3.

                 o
          0    /   \
              o
          1   /\   /\
               o
          1  /\/\ /\/\
                o

    Combining this with the previous picture, we have

         - 0     - 0       - 1     - 1
      0 /       1 \     0 /      1  \
        -         -       -         +

         + 0     + 0       + 1     + 1
      0 /       1 \     0 /      1  \
        -         +       +         +

    If B is the l-th bit of n, C is the color and D is the direction,
    the color of a child is obtained from the color of the parent by
    the following boolean formula

        ~CBD + C~(~B~D) = ~B(CD) + B~(~C~D) = ~D(BC) + D~(~B~C)

    where black evaluates to true and white to false.  Most
    importantly, if B=D, then the color of the child is B; if B!=D,
    the color of the child is C. The function color below implements
    exactly this algorithm to determine the color of an arbitrary
    node. Observe that each internal node is visited exactly once, so
    there is no point in caching the color of already discovered nodes
    (well, as long as we just look at just one level).

    The algorithm follows. Start from the lowest complete level. Each
    white node is a no-op: just copy one coefficient of P. For each
    black node take two coefficient from P and combine them as g*a +
    f*b. If n is a power of two, this step just does nothing (well, it
    copies the array in python); if it is not, this step leaves an
    array of length a power of two.

    Now, for each level h, compute

        ll, lh = g^(n >> h), g^((n >> h) + 1)
        rl, rh = f^(n >> h), f^((n >> h) + 1)

    this can be done from the knowledge of the previous two powers of
    g and f with four multiplications of equal-sized polynomials, in a
    montgomery-ladder style.

    Read the nodes two-by-two from left to right. For each pair (a,b)
    compute their color and replace them with A*a + B*b, where A is
    either ll or lh and B is either rl or rh, according to the colors
    of the nodes.

    At each level, at most three values among ll, lh, rl, rh are
    needed, but it is a lot easier to compute the four of them, so
    that the montgomery-ladder goes smoothly. I'm not sure, but it
    might be possible to know from the beginning that rh or ll or both
    will never be used, this could help saving some more space and
    computation.

    If the coefficients of P have degree max(deg f, deg g) - 1, the
    output of A*a + B*b takes as much space as its input, so
    everything can be done in place (although it is not in this
    implementation).
    """
    if not Ps:
        return f.parent()(0)

    n = len(Ps)
    
    def color(i, n, h):
        while h > 0:
            if bool(i & 1) == bool(n & (1 << (h - 1))):
                return bool(i & 1)
            i = i >> 1
            h -= 1
        return False

    res = []
    ptr = 0
    h = n.bit_length() - 1
    for i in range(1 << h):
        if color(i, n, h):
            res.append(g*Ps[ptr] + f*Ps[ptr+1])
            ptr += 2
        else:
            res.append(Ps[ptr])
            ptr += 1
    Ps = res

    ll, lh = 1, g
    rl, rh = 1, f
    for h in reversed(range(n.bit_length() - 1)):
        if n & (1 << (h + 1)):
            ll, lh = ll * lh, lh**2
            rl, rh = rl * rh, rh**2
        else:
            ll, lh = ll**2, ll * lh
            rl, rh = rl**2, rl * rh
        res = []
        b = n & (1 << h)
        for i in range(1 << h):
            col = color(i, n, h)
            if col and b:
                res.append(lh*Ps[2*i] + rh*Ps[2*i+1])
            elif col or b:
                res.append(lh*Ps[2*i] + rl*Ps[2*i+1])
            else:
                res.append(ll*Ps[2*i] + rl*Ps[2*i+1])
        Ps = res

    return Ps[0]


def decompose(P, f, g=None, target=None):
    """
    Compute a polynomial Q of degree target such that compose(Q, f,
    g).  Assumes deg f >= deg g. The result is returned as a list of
    coefficients.
    """

    def dec(P, f, g, invf, invg):
        a = f.parent()(0)
        if P.degree() >= f.degree() + g.degree():
            a, P = P.quo_rem(f)
            
        return a + (P * invf) % g, (P * invg) % f
        
    if g is None:
        g = f.parent()(1)
    if target is None:
        target = ZZ(P.degree() // f.degree())
    n, a, b = 0, 1, 1
    moduli = []
    for bit in reversed(target.bits()):
        if bit:
            n1, a1, b1 = n+1, a*f, b*g
        else:
            n1, a1, b1 = n, a, b
        moduli.append((n1, a1, b1))
        n, a, b = n + n1, a*a1, b*b1

    res = {0: P}
    for n, a, b in reversed(moduli):
        newres = {}
        _, inva, invb = a.xgcd(b)
        for i, p in res.iteritems():
            p0, p1 = dec(p, a, b, inva, invb)
            newres[i+n] = p0 + newres.get(i+n, 0)
            newres[i] = p1 + newres.get(i, 0)
        res = newres

    return [res[i] for i in range(len(res))]
